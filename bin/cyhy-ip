#!/usr/bin/env python
"""Manage IP address assignments to owners.

Usage:
  cyhy-ip [--section SECTION] [--file FILENAME] (add | compare | remove) OWNER [ADDRESSES ...]
  cyhy-ip [--section SECTION] [--file FILENAME] (check | normalize) [ADDRESSES ...]
  cyhy-ip [--section SECTION] [--file FILENAME] setstage STAGE [ADDRESSES ...]
  cyhy-ip [--section SECTION] list OWNER
  cyhy-ip [--section SECTION] list-all
  cyhy-ip [--section SECTION] [--file FILENAME] move OWNER NEW_OWNER [ADDRESSES ...]
  cyhy-ip (-h | --help)
  cyhy-ip --version

Options:
  -h --help                      Show this screen.
  --version                      Show version.

  -f FILENAME --file=FILENAME    Read addresses from a file.
  -s SECTION --section=SECTION   Configuration section to use.

Notes:
  Address can be read from standard input if no addresses are provided on the command line
  and the --file option is omitted.

"""

from __future__ import print_function

import sys
import progressbar as pb
from docopt import docopt
from netaddr import ip, IPNetwork, IPRange, IPSet
from cyhy.core import STATUS, STAGE
from cyhy.db import database, CHDatabase
from cyhy.util import util
from cyhy.core.geoloc import GeoLocDB
from cyhy.core.common import TICKET_EVENT


def munge(ip_addrs):
    """Munges a tuple or list of IPNetwork and IPRange objects into a single IPSet.

    Args:
        x: A Python tuple or list containing IPNetwork and IPRange objects

    Returns:
        An IPSet corresponding to the Python tuple or list that was passed in.

    """
    ans = []
    for i in ip_addrs:
        # IPSet doesn't like it when an IPRange appears in the tuple
        # or list in its constructor.  It only likes IPNetworks.
        if isinstance(i, IPRange):
            ans.extend(i.cidrs())
        else:
            ans.append(i)
    return IPSet(ans)


PB_INIT_WIDGETS = [
    "Initializing: ",
    pb.SimpleProgress(),
    " ",
    # MIGRATION : unichr becomes chr in Py3
    pb.Bar(marker=unichr(0x25B6)),
    " ",
    pb.ETA(),
]

# Only IPV4_LOOPBACK and IPV4_RESERVED need to be munged, since the
# others are not lists or tuples
SPECIAL_RANGES = {
    "IPv4 Loopback": IPSet(ip.IPV4_LOOPBACK),
    "IPv4 Private": munge(ip.IPV4_PRIVATE),
    "IPv4 Link Local": IPSet(ip.IPV4_LINK_LOCAL),
    "IPv4 Multicast": IPSet(ip.IPV4_MULTICAST),
    "IPv4 6 to 4": IPSet(ip.IPV4_6TO4),
    "IPv4 Reserved": munge(ip.IPV4_RESERVED),
}


def parse_addresses(addresses):
    """Parse the provided addresses to create an IPSet."""
    nets = IPSet()
    for addr in addresses:
        addr = addr.split("#", 1)[0]  # remove comments
        addr = addr.strip()
        if not addr:
            # skip blank lines
            continue
        if addr.find("-") != -1:
            # handle a range
            start, end = addr.split("-")
            rng = IPRange(start.strip(), end.strip())
            for i in rng.cidrs():
                nets.add(i)
        else:
            # handle single cidr
            net = IPNetwork(addr)
            nets.add(net)
    return nets


def read_file(filename):
    """Read in a file and parse it for IP addresses."""
    with open(filename) as f:
        contents = f.readlines()
    return parse_addresses(contents)


def get_special_intersections(cidrs):
    """Get the intersection of the given CIDRs with special IP ranges."""
    results = {}  # {request: IPSet of intersections}
    for description, special_set in SPECIAL_RANGES.items():
        intersection = special_set & cidrs
        if intersection:
            results[description] = intersection
    return results


def print_intersections(intersections):
    """Print the provided IP intersections."""
    for request, intersecting_cidrs in intersections.items():
        if isinstance(request, str):
            print("# {!s}: {:,}".format(request, len(intersecting_cidrs)))
        else:
            print(
                "# {!s} ({!s}): {:,}".format(
                    request["agency"]["name"], request["_id"], len(intersecting_cidrs)
                )
            )
        print_cidrs(intersecting_cidrs, indent=1)
        print()


def print_cidrs(cidrs, indent=0):
    """Print the provided CIDRs."""
    for i in cidrs.iter_cidrs():
        print("\t" * indent + str(i))


def check(mongo_db, cidrs):
    """Check if the given CIDRs are already in the database."""
    intersections = mongo_db.RequestDoc.get_all_intersections(
        cidrs
    )  # intersections from database
    intersections.update(get_special_intersections(cidrs))  # intersections with RFCs
    print_intersections(intersections)
    matched = IPSet()
    for intersecting_cidrs in intersections.values():
        matched.update(intersecting_cidrs)
    unmatched = cidrs - matched
    if unmatched:
        print("Unmatched: {:,}".format(len(unmatched)))
        print_cidrs(unmatched, indent=1)


def do_list(mongo_db, owner):
    """List the IP ranges owned by the given org."""
    request = mongo_db.RequestDoc.find_one({"_id": owner})
    if request:
        for i in request["networks"]:
            print(i)
    else:
        print("ERROR: Organization {!s} not found in DB".format(owner))


def do_list_all(mongo_db):
    """Print all owned IP addresses in the database."""
    intersections = mongo_db.RequestDoc.get_all_intersections(IPSet(["0.0.0.0/0"]))
    print_intersections(intersections)


def add(mongo_db, owner, cidrs):
    """Add the given CIDRs to the provided owner's inventory."""
    intersections = mongo_db.RequestDoc.get_all_intersections(
        cidrs
    )  # intersections from database
    intersections.update(get_special_intersections(cidrs))  # intersections with RFCs
    if intersections:
        print("Cannot continue!\nSome addresses already allocated or reserved:")
        print_intersections(intersections)
        sys.exit(-1)
    request = mongo_db.RequestDoc.find_one({"_id": owner})
    # init new hosts documents
    # get the init_stage, if it doesn't have one assume NETSCAN1
    stage = STAGE[request.get("init_stage", STAGE.NETSCAN1)]
    geo_loc_db = GeoLocDB()
    pbar = pb.ProgressBar(widgets=PB_INIT_WIDGETS, maxval=len(cidrs)).start()
    pbar.widgets[0] = "Adding %s: " % owner
    i = 0
    for ipa in cidrs:
        location = geo_loc_db.lookup(ipa)
        host = mongo_db.HostDoc()
        host.init(ipa, owner, location, stage)
        host.save()
        i += 1
        pbar.update(i)
    # update request with new networks
    request.add_networks(cidrs)
    request.save()
    print(
        "IPs added to request, and initialized.  Tally sync required to start scan of new IPs."
    )
    sys.exit(0)


def remove(mongo_db, owner, cidrs):
    """Remove the given CIDRs from the specified owner's inventory."""
    intersections = mongo_db.RequestDoc.get_all_intersections(cidrs)
    if not intersections:
        print("Cannot continue!\nAddress is not allocated.")
        sys.exit(-1)
    if len(intersections) > 1 or intersections.keys()[0]["_id"] != owner:
        print(
            "Cannot continue!\nSome addresses are allocated to owners other than {!s}:".format(
                owner
            )
        )
        print_intersections(intersections)
        sys.exit(-1)
    request = intersections.keys()[0]

    # clear latest flags and remove host documents
    pbar = pb.ProgressBar(widgets=PB_INIT_WIDGETS, maxval=len(cidrs)).start()
    pbar.widgets[0] = "Removing {!s}: ".format(owner)
    i = 0
    ticket_closing_time = util.utcnow()
    for net in cidrs.iter_cidrs():
        # clear lastest flags on ip ranges
        mongo_db.HostScanDoc.collection.update(
            spec={"ip_int": {"$gte": net.first, "$lte": net.last}},
            document={"$set": {"latest": False}},
            multi=True,
        )
        mongo_db.PortScanDoc.collection.update(
            spec={"ip_int": {"$gte": net.first, "$lte": net.last}},
            document={"$set": {"latest": False}},
            multi=True,
        )
        mongo_db.VulnScanDoc.collection.update(
            spec={"ip_int": {"$gte": net.first, "$lte": net.last}},
            document={"$set": {"latest": False}},
            multi=True,
        )
        # remove hosts by their integer ranges
        mongo_db.HostDoc.collection.remove(
            {"_id": {"$gte": net.first, "$lte": net.last}}
        )
        # close open tickets in this ip range
        for ticket in mongo_db.TicketDoc.find(
            {"ip_int": {"$gte": net.first, "$lte": net.last}, "open": True}
        ):
            ticket["open"] = False
            ticket["time_closed"] = ticket_closing_time
            ticket.add_event(
                TICKET_EVENT.CLOSED, "host moved out of scope", time=ticket_closing_time
            )
            ticket.save()
        i += len(net)
        pbar.update(i)
    # update request with new networks
    request.remove_networks(cidrs)
    request.save()
    print()
    print(
        "IPs removed from request, host documents deleted, open tickets "
        "closed, and relevant reports latest flags cleared."
    )


def wrapped_remove(mongo_db, owner, cidrs):
    """Remove IP addresses and then exit."""
    remove(mongo_db, owner, cidrs)
    sys.exit(0)


def compare(mongo_db, owner, new_net_set):
    """Show changes between new and old CIDRs for the given owner."""
    old_net_set = mongo_db.RequestDoc.find_one({"_id": owner}).networks

    added = new_net_set - old_net_set
    removed = old_net_set - new_net_set
    unchanged = old_net_set.intersection(new_net_set)

    print("New Network List ({:,} addresses)".format(len(new_net_set)))
    for net in new_net_set.iter_cidrs():
        print(net)

    print()
    print("Previous Network List ({:,} addresses)".format(len(old_net_set)))
    for net in old_net_set.iter_cidrs():
        print(net)

    print()
    print("Unchanged Networks ({:,} addresses)".format(len(unchanged)))
    for net in unchanged.iter_cidrs():
        print(net)

    print()
    print("Added Networks ({:,} addresses)".format(len(added)))
    for net in added.iter_cidrs():
        print(net)

    print()
    print("Removed Networks ({:,} addresses)".format(len(removed)))
    for net in removed.iter_cidrs():
        print(net)

    print()
    print("Net address count change: {:,}".format(len(new_net_set) - len(old_net_set)))
    sys.exit(0)


def move(mongo_db, orig_owner, new_owner, networks_to_move):
    """Transfer the given CIDRs from the current owner to a new owner."""
    if orig_owner == new_owner:
        print(
            "ERROR: OWNER is the same as NEW_OWNER ({!s}).".format(orig_owner),
            "EXITING without making any changes.",
        )
        sys.exit(-1)
    orig_owner_request = mongo_db.RequestDoc.get_by_owner(orig_owner)
    new_owner_request = mongo_db.RequestDoc.get_by_owner(new_owner)
    for (org, req) in [
        (orig_owner, orig_owner_request),
        (new_owner, new_owner_request),
    ]:
        if not req:
            print("ERROR: Organization {!s} not found in DB".format(org))
            sys.exit(-1)

    orig_owner_nets = orig_owner_request.networks
    cidrs_not_in_orig_owner = networks_to_move - orig_owner_nets
    if cidrs_not_in_orig_owner:
        print(
            "\nERROR: The following networks are NOT part of {!s}:".format(
                orig_owner_request["_id"]
            )
        )
        for net in cidrs_not_in_orig_owner.iter_cidrs():
            print("\t {!s}".format(net))
        print("EXITING without making any changes.")
        sys.exit(-1)

    if not util.warn_and_confirm(
        "This will modify database documents.  "
        "You should PAUSE the CyHy commander before continuing."
    ):
        print("Aborted.")
        sys.exit(-2)

    cyhy_db = CHDatabase(mongo_db)
    # Change owner on all relevant documents
    cyhy_db.change_ownership(
        orig_owner_request["_id"],
        new_owner_request["_id"],
        networks_to_move,
        "host owner changed",
    )

    # Check to see if new_owner has a different scheduler than orig_owner
    # (None == manual scheduler; not None == persistent scanning)
    if (orig_owner_request.get("scheduler") is None) and (
        new_owner_request.get("scheduler") is not None
    ):
        mongo_db.HostDoc.ensure_next_scan_set(
            new_owner_request["_id"]
        )  # Ensure a next_scan date is set for all hosts in the new owner
    elif (orig_owner_request.get("scheduler") is not None) and (
        new_owner_request.get("scheduler") is None
    ):
        mongo_db.HostDoc.clear_next_scan_date(
            new_owner_request["_id"]
        )  # Clear the next_scan date

    # Remove the networks_to_move from orig_owner's request doc
    orig_owner_request.remove_networks(networks_to_move)
    # Add the networks_to_move to new_owner's request doc
    new_owner_request.add_networks(networks_to_move)

    # Save both request docs
    orig_owner_request.save()
    new_owner_request.save()

    orig_owner_tally = mongo_db.TallyDoc.get_by_owner(orig_owner_request["_id"])
    new_owner_tally = mongo_db.TallyDoc.get_by_owner(new_owner_request["_id"])

    # Sync from/to org tallies
    for (org, tally) in [
        (orig_owner_request["_id"], orig_owner_tally),
        (new_owner_request["_id"], new_owner_tally),
    ]:
        if not tally:
            print(
                "WARNING: Organization {!s} does NOT have a tally document!".format(org)
            )
        else:
            print("Syncing tally for {!s}".format(org))
            tally.sync(mongo_db)
    print("SUCCESS!")
    sys.exit(0)


def setstage(mongo_db, stage, cidrs):
    """Set the scanning stage for the given CIDRs to the given stage."""
    intersections = mongo_db.RequestDoc.get_all_intersections(
        cidrs
    )  # intersections from database
    matched = IPSet()
    for intersecting_cidrs in intersections.values():
        matched.update(intersecting_cidrs)

    special_intersections = get_special_intersections(cidrs)  # intersections with RFCs
    special = IPSet()
    for intersecting_cidrs in special_intersections.values():
        special.update(intersecting_cidrs)
    unmatched = cidrs - matched - special

    if unmatched:
        print(
            "\nThe following networks were not found in CyHy inventory",
            "and will be skipped:",
            len(unmatched),
        )
        print_cidrs(unmatched, indent=1)
    if special:
        print("\nThe following networks are reserved and will be skipped:")
        print_intersections(special_intersections)
    if not matched:
        print("No networks found; exiting!")
        sys.exit(0)

    print(
        "The following networks were found in CyHy inventory",
        "and their stage will be set to {!s}/WAITING:".format(stage),
    )
    print_intersections(intersections)
    if not util.warn_and_confirm(
        "This will modify the host document for each address listed above!"
    ):
        print("Aborted.")
        sys.exit(-2)

    print("\nUpdating host documents...")
    pbar = pb.ProgressBar(widgets=PB_INIT_WIDGETS, maxval=len(matched)).start()
    pbar.widgets[0] = "Setting stage: "
    i = 0
    for net in matched.iter_cidrs():
        mongo_db.HostDoc.collection.update(
            spec={"_id": {"$gte": net.first, "$lte": net.last}},
            document={
                "$set": {
                    "stage": STAGE[stage],
                    "status": STATUS.WAITING,
                    "next_scan": None,
                    "state.up": True,
                    "state.reason": "set-stage",
                }
            },
            multi=True,
        )
        i += len(net)
        pbar.update(i)

    print("\n")
    for org in intersections.keys():
        tally = mongo_db.TallyDoc.get_by_owner(org["_id"])
        print("Syncing tally for {!s}".format(org["_id"]))
        tally.sync(mongo_db)
    print("SUCCESS!")
    sys.exit(0)


def main():
    """Provide utilities to manage IP inventories in the CyHy database."""
    args = docopt(__doc__, version="v0.0.1")

    mongo_db = database.db_from_config(args["--section"])

    if args["list"]:
        do_list(mongo_db, args["OWNER"])
        sys.exit(0)

    if args["list-all"]:
        do_list_all(mongo_db)
        sys.exit(0)

    nets = parse_addresses(args["ADDRESSES"])
    if args["--file"] is not None:
        f_nets = read_file(args["--file"])
        nets.update(f_nets)
    elif not nets:
        nets.update(parse_addresses(sys.stdin.readlines()))

    if args["check"]:
        check(mongo_db, nets)
    elif args["normalize"]:
        print("#", len(nets))
        print_cidrs(nets, indent=0)
    elif args["add"]:
        add(mongo_db, args["OWNER"], nets)
    elif args["remove"]:
        wrapped_remove(mongo_db, args["OWNER"], nets)
    elif args["compare"]:
        compare(mongo_db, args["OWNER"], nets)
    elif args["move"]:
        move(mongo_db, args["OWNER"], args["NEW_OWNER"], nets)
    elif args["setstage"]:
        stage = args["STAGE"]
        # Make sure the stage the user specified is valid
        if stage not in STAGE:
            print(stage + " is not a valid stage.", file=sys.stderr)
            print("Valid stages are: {}".format(" ".join(STAGE)), file=sys.stderr)
            sys.exit(1)

        setstage(mongo_db, stage, nets)


if __name__ == "__main__":
    main()
