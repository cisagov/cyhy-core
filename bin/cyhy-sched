#!/usr/bin/env python
"""Control how and when organizations are scanned.

Usage:
  cyhy-sched [options] single-scan DATE OWNER ...
  cyhy-sched [options] persistent-scan [--update-hosts] [--start-on DATE] OWNER ...
  cyhy-sched [options] pause OWNER ...
  cyhy-sched [options] unpause DATE OWNER ...
  cyhy-sched (-h | --help)
  cyhy-sched --version

Options:
  --version                      Show version.
  --no-prompt                    Execute without confirmation prompt.
  --start-on DATE                Set future scan date for persistent scan.
  --no-descendants               Do not include descendants of OWNER.
  -s SECTION --section=SECTION   Configuration section to use.
"""

from __future__ import print_function

import os
import sys

from docopt import docopt
import dateutil.parser
import dateutil.tz as tz

from cyhy.core import STAGE
from cyhy.db import database
from cyhy.util import time_to_utc, utcnow


THE_ONLY_SCHEDULER = "PERSISTENT1"
THE_DISTANT_FUTURE = dateutil.parser.parse("9999-01-01")


def set_start_date(request, start_time, clear_scheduler=False):
    """Set a new start date for the given request."""
    print("\tSetting start time to", start_time, file=sys.stderr)
    if clear_scheduler and request.get("scheduler") is not None:
        print("\tRemoving persistent scheduler.", file=sys.stderr)
        request["scheduler"] = None
    request.start_time = start_time
    request.save()
    print("\tModified request saved.", file=sys.stderr)


def reset_state(mongo_db, request, start_time):
    """Reset the state of the given request."""
    # MIGRATION : This entire approach was deprecated, please see:
    # https://stackoverflow.com/questions/67631/how-to-import-a-module-given-the-full-path
    # for alternatives (we should use the Python 3.5+ approach).
    # crazy hack to import cyhy-tool
    import imp

    this_file = os.path.realpath(__file__)
    this_dir = os.path.dirname(this_file)
    ch_tool = imp.load_source("ch_tool", os.path.join(this_dir, "cyhy-tool"))

    # get the init_stage, if it doesn't have one assume NETSCAN1
    init_stage = STAGE[request.get("init_stage", STAGE.NETSCAN1)]
    set_start_date(request, start_time, clear_scheduler=True)
    # reset state of all hosts
    print(
        "\tResetting state of hosts to {!s} and PORTSCAN ...".format(init_stage),
        file=sys.stderr,
    )
    mongo_db.HostDoc.reset_state_by_owner(request["_id"], init_stage, jump_start=True)
    # sync tallies
    print("\tSynchronizing tallies...", file=sys.stderr)
    ch_tool.sync_tallies(mongo_db, request["_id"])


def make_persistent(mongo_db, request, update_hosts, start_date):
    """Update a given request to be the 'PERSISTENT1' scheduler."""
    print("\tSetting scheduler to", THE_ONLY_SCHEDULER, file=sys.stderr)
    request["scheduler"] = THE_ONLY_SCHEDULER
    request.start_time = start_date
    request.save()
    print("\tModified request saved.", file=sys.stderr)
    if update_hosts:
        print('\tEnsuring all hosts have a "next scan" date.', file=sys.stderr)
        mongo_db.HostDoc.ensure_next_scan_set(request["_id"])


def parse_date(args):
    """Try to parse a date from the given string."""
    try:
        start_time_local = dateutil.parser.parse(args["DATE"])
    except ValueError:
        print("Could not parse the date:", args["DATE"], file=sys.stderr)
        sys.exit(-1)
    except OverflowError:
        print(
            "Provided date '{}' is too large for this system.".format(args["DATE"]),
            file=sys.stderr,
        )
        sys.exit(-1)

    if start_time_local.tzinfo is None:
        start_time_local = start_time_local.replace(tzinfo=tz.tzlocal())
    start_time_utc = time_to_utc(start_time_local)

    return start_time_local, start_time_utc


def build_owner_list(mongo_db, args):
    """Build a list of all owners (and optionally their descendants)."""
    result = []
    args["descendants-included"] = False
    for owner in args["OWNER"]:
        result.append(owner)
        descendants = mongo_db.RequestDoc.get_all_descendants(owner)
        if descendants and not args["--no-descendants"]:
            args["descendants-included"] = True
            result.extend(descendants)

    return result


def parse_owners(mongo_db, args):
    """Verify that all the provided owners are in the database."""
    all_requests_found = True
    requests = []
    for owner in build_owner_list(mongo_db, args):
        request = mongo_db.RequestDoc.get_by_owner(owner)
        if request is None:
            print('No request with "{}" found.'.format(owner), file=sys.stderr)
            all_requests_found = False
        else:
            requests.append(request)
    if not all_requests_found:
        sys.exit(-1)

    return requests


def prompt(args):
    """Verify that the user wants to include descendants."""
    if not args["--no-prompt"]:
        print("", file=sys.stderr)
        if args["descendants-included"]:
            print("To exclude descendants use the --no-descendants flag.\n")
        # MIGRATION : raw_input() becomes input() in Python 3
        yes = raw_input('Type "yes" if you are sure that you want to do this? ')
        if yes != "yes":
            print("Aborted.", file=sys.stderr)
            sys.exit(-2)
        print("", file=sys.stderr)


def main():
    """Manage scheduling for owners and optionally their descendants."""
    args = docopt(__doc__, version="v0.0.1")
    mongo_db = database.db_from_config(args["--section"])
    requests = parse_owners(mongo_db, args)

    for request in requests:
        print(
            "Modifying owner:\t{!s}: {!s} ({!s})".format(
                request["_id"], request["agency"]["name"], request["agency"]["acronym"],
            ),
            file=sys.stderr,
        )

    if args["single-scan"]:
        start_time_local, start_time_utc = parse_date(args)
        print("WARNING: This will modify many of the Host documents.", file=sys.stderr)
        print(
            "Do not scan before:\t{!s} ({!s})".format(
                start_time_local, start_time_utc,
            ),
            file=sys.stderr,
        )
        prompt(args)
        for request in requests:
            print("Processing:", request["_id"], file=sys.stderr)
            reset_state(mongo_db, request, start_time_utc)
    elif args["persistent-scan"]:
        if args["--update-hosts"]:
            print(
                "WARNING: This will modify many of the Host documents.", file=sys.stderr
            )
        if args["--start-on"]:
            args["DATE"] = args["--start-on"]
            start_time_local, start_time_utc = parse_date(args)
            start_time = start_time_utc
            print(
                "Do not scan before:\t{!s} ({!s})".format(
                    start_time_local, start_time_utc,
                ),
                file=sys.stderr,
            )
        else:
            start_time = utcnow()
        prompt(args)
        for request in requests:
            print("Processing:", request["_id"], file=sys.stderr)
            make_persistent(mongo_db, request, args["--update-hosts"], start_time)
    elif args["pause"]:
        print("Pausing scans.", file=sys.stderr)
        prompt(args)
        for request in requests:
            print("Processing:", request["_id"], file=sys.stderr)
            set_start_date(request, THE_DISTANT_FUTURE)
    elif args["unpause"]:
        start_time_local, start_time_utc = parse_date(args)
        print("Unpausing scans by setting new start time.", file=sys.stderr)
        print(
            "Do not scan before:\t{!s} ({!s})".format(
                start_time_local, start_time_utc,
            ),
            file=sys.stderr,
        )
        prompt(args)
        for request in requests:
            print("Processing:", request["_id"], file=sys.stderr)
            set_start_date(request, start_time_utc)


if __name__ == "__main__":
    main()
