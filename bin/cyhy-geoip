#!/usr/bin/env python
"""Cyber Hygiene GeoIP maintenance tool.

Usage:
  cyhy-geoip [options] check ADDRESS
  cyhy-geoip [options] update [OWNER]

Options:
  -h --help                      Show this screen.
  --version                      Show version.

  -s SECTION --section=SECTION   Configuration section to use.
  -d --debug                     Output debug messages.
"""

import logging

from docopt import docopt
from netaddr import ip, IPAddress, IPNetwork, IPRange, IPSet
from netaddr.core import AddrFormatError
import pymongo

from cyhy.core.geoloc import GeoLocDB
from cyhy.db import database
from cyhy.util import util


def munge(network_list):
    """Munges a tuple or list of IPNetwork and IPRange objects into a single IPSet.

    Args:
        network_list: A Python tuple or list containing IPNetwork and IPRange objects

    Returns:
        An IPSet corresponding to the Python tuple or list that was passed
        in.
    """
    fixed_list = []
    for net in network_list:
        # IPSet doesn't like it when an IPRange appears in the tuple
        # or list in its constructor.  It only likes IPNetworks.
        if isinstance(net, IPRange):
            fixed_list.extend(net.cidrs())
        else:
            fixed_list.append(net)
    return IPSet(fixed_list)


UPDATE_INCREMENT = 100000
LOG_FILE = "/var/log/cyhy/geoip.log"
# Only IPV4_LOOPBACK and IPV4_RESERVED need to be munged, since the
# others are not lists or tuples
SPECIAL_RANGES = {
    "IPv4 Loopback": IPSet(ip.IPV4_LOOPBACK),
    "IPv4 Private": munge(ip.IPV4_PRIVATE),
    "IPv4 Link Local": IPSet(ip.IPV4_LINK_LOCAL),
    "IPv4 Multicast": IPSet(ip.IPV4_MULTICAST),
    "IPv4 6 to 4": IPSet(ip.IPV4_6TO4),
    "IPv4 Reserved": munge(ip.IPV4_RESERVED),
}


def get_special_intersections(cidrs):
    results = dict()  # {request: IPSet of intersections}
    for description, special_set in SPECIAL_RANGES.items():
        intersection = special_set & cidrs
        if intersection:
            results[description] = intersection
    return results


def check_special_intersections(ip_addr):
    intersections = get_special_intersections(IPSet([ip_addr]))
    if intersections:
        print "Problem with provided address:"
        for group, intersecting_cidrs in intersections.iteritems():
            print "\t{!s} found in {!s}".format(intersecting_cidrs.pop(), group)
        return True

    return False


def main():
    args = docopt(__doc__, version="v0.0.1")

    cyhy_db = database.db_from_config(args["--section"])
    geoip_db = GeoLocDB()

    # Set up logging
    logger = logging.getLogger("cyhy-geoip")
    if args["--debug"]:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    util.setup_logging(log_level, filename=LOG_FILE)

    if args["check"]:
        ip_to_check = IPAddress(args["ADDRESS"])

        if not check_special_intersections(ip_to_check):
            cyhy_info = cyhy_db.HostDoc.find_one({"_id": long(ip_to_check)})
            geoip_loc = list(geoip_db.lookup(ip_to_check))

            if cyhy_info["loc"] != geoip_loc:
                print "{!s} location in CyHy database does not match GeoIP2 database.".format(
                    ip_to_check
                )
                print "\tCyHy Location (long, lat): {}".format(cyhy_info["loc"])
                print "\tGeoIP2 Location (long, lat): {}".format(geoip_loc)
            else:
                print "CyHy location is up to date."
    elif args["update"]:
        query = None
        if args["OWNER"]) is not None:
            query = {"owner": args["OWNER"]}
        hosts = cyhy_db.HostDoc.find(query)
        total_documents = hosts.count()

        if query is None:
            header_message = "Beginning update of GeoIP data for all hosts [{:,} document(s)]".format(
                total_documents
            )
        else:
            header_message = "Beginning update of GeoIP data for all hosts belonging to '{:s}' [{:,} document(s)]".format(
                args["OWNER"], total_documents
            )

        logger.info(header_message)

        total_processed = 0
        total_updated = 0
        for host in hosts:
            check_special_intersections(host["ip"])
            # lookup() returns a tuple but the host object stores it as a list
            new_loc = list(geoip_db.lookup(host["ip"]))
            if new_loc != host["loc"]:
                old_loc = host["loc"]
                host["loc"] = new_loc
                host.save()
                total_updated += 1
                logger.debug(
                    "Host {0!s} location changed from [{1[0]!s}, {1[1]!s}] to [{2[0]!s}, {2[1]!s}]".format(
                        host["ip"], old_loc, new_loc
                    )
                )

            total_processed += 1
            if (total_processed % UPDATE_INCREMENT) == 0:
                logger.info(
                    "Processed {:,}/{:,} host document(s) ({:,} updated)".format(
                        total_processed, total_documents, total_updated
                    )
                )

        logger.info(
            "Finished update with {:,} document(s) updated".format(total_updated)
        )


if __name__ == "__main__":
    main()
