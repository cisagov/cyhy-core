#!/usr/bin/env python
"""Cyber Hygiene GeoIP maintenance tool.

Usage:
  cyhy-geoip [options] check ADDRESS
  cyhy-geoip [options] update [--live-only] [OWNER] ...

Arguments:
  ADDRESS  The IP address whose GeoIP data should be checked.
  OWNER    An owner whose hosts should have GeoIP data refreshed.

Options:
  -h, --help                     Show this screen.
  --version                      Show version.
  -s SECTION, --section=SECTION  Configuration section to use.
  -d, --debug                    Output debug messages.
  --live-only                    Update only hosts that are up.
"""

from __future__ import print_function

import logging

from docopt import docopt
from netaddr import ip, IPAddress, IPRange, IPSet

from cyhy.core.geoloc import GeoLocDB
from cyhy.db import database
from cyhy.util import util


def munge(network_list):
    """Munges a tuple or list of IPNetwork and IPRange objects into a single IPSet.

    Args:
        network_list: A Python tuple or list containing IPNetwork and IPRange objects.

    Returns:
        An IPSet corresponding to the Python tuple or list that was passed in.

    """
    fixed_list = []
    for net in network_list:
        # IPSet doesn't like it when an IPRange appears in the tuple
        # or list in its constructor.  It only likes IPNetworks.
        if isinstance(net, IPRange):
            fixed_list.extend(net.cidrs())
        else:
            fixed_list.append(net)
    return IPSet(fixed_list)


# How often do we output progress (every UPDATE_INCREMENT documents)
UPDATE_INCREMENT = 100000

# Logging core variables
LOGGER = logging.getLogger("cyhy-geoip")
LOG_FILE = "/var/log/cyhy/geoip.log"
DEFAULT_LOGGER_LEVEL = logging.INFO

# Only IPV4_LOOPBACK and IPV4_RESERVED need to be munged, since the
# others are not lists or tuples
SPECIAL_RANGES = {
    "IPv4 Loopback": IPSet(ip.IPV4_LOOPBACK),
    "IPv4 Private": munge(ip.IPV4_PRIVATE),
    "IPv4 Link Local": IPSet(ip.IPV4_LINK_LOCAL),
    "IPv4 Multicast": IPSet(ip.IPV4_MULTICAST),
    "IPv4 6 to 4": IPSet(ip.IPV4_6TO4),
    "IPv4 Reserved": munge(ip.IPV4_RESERVED),
}


def logging_setup(debug_logging):
    """Set up the logging configuration."""
    if debug_logging:
        level = logging.DEBUG
    else:
        level = DEFAULT_LOGGER_LEVEL
    util.setup_logging(level, filename=LOG_FILE)
    # Only output if debug is enabled.  Skipped otherwise.
    LOGGER.debug("Debug logging enabled")


def get_special_intersections(cidrs):
    """Generate intersections between a given CIDR and the special IP ranges."""
    results = dict()  # {request: IPSet of intersections}
    for description, special_set in SPECIAL_RANGES.items():
        intersection = special_set & cidrs
        if intersection:
            results[description] = intersection
    return results


def check_special_intersections(ip_addr):
    """Check to see if a given IP address is in a special IP range."""
    intersections = get_special_intersections(IPSet([ip_addr]))
    if intersections:
        print("Problem with provided address:")
        for group, intersecting_cidrs in intersections.items():
            print("\t{!s} found in {!s}".format(intersecting_cidrs.pop(), group))
        return True

    return False


def do_check(cyhy_db, geoip_db, address):
    """Check the geolocation of a given IP address."""
    ip_to_check = IPAddress(address)

    if not check_special_intersections(ip_to_check):
        # MIGRATION : long() is Py2 only, replace with int()
        cyhy_info = cyhy_db.HostDoc.find_one({"_id": long(ip_to_check)})
        geoip_loc = list(geoip_db.lookup(ip_to_check))

        if cyhy_info["loc"] != geoip_loc:
            print(
                "Location of '{!s}' in CyHy database does not match GeoIP database.".format(
                    ip_to_check
                )
            )
            print("\tCyHy Location (long, lat): ", cyhy_info["loc"])
            print("\tGeoIP Location (long, lat): ", geoip_loc)
        else:
            print("CyHy location is up to date.")


def do_update(cyhy_db, geoip_db, up_only=False, owner=None):
    """Update the GeoIP data for all hosts, or only those of the given owner."""
    # Set up find query.
    query = {}
    if owner is not None:
        query["owner"] = owner
    if up_only:
        query["state.up"] = True

    hosts = cyhy_db.HostDoc.find(query)
    total_documents = hosts.count()

    LOGGER.info(
        "Beginning update of GeoIP data for all %shosts %s[%s document(s)]",
        "live " if up_only else "",
        "belonging to '{:s}' ".format(owner) if owner is not None else "",
        "{:,}".format(total_documents),
    )

    total_processed = 0
    total_updated = 0
    for host in hosts:
        check_special_intersections(host["ip"])
        # lookup() returns a tuple but the host object stores it as a list
        new_loc = list(geoip_db.lookup(host["ip"]))
        if new_loc != host["loc"]:
            old_loc = host["loc"]
            host["loc"] = new_loc
            host.save()
            total_updated += 1
            LOGGER.debug(
                "Host %s location changed from [%s, %s] to [%s, %s]",
                host["ip"],
                old_loc[0],
                old_loc[1],
                new_loc[0],
                new_loc[1],
            )

        total_processed += 1
        if (total_processed % UPDATE_INCREMENT) == 0:
            LOGGER.info(
                "Processed %s/%s host document(s) (%s updated)",
                "{:,}".format(total_processed),
                "{:,}".format(total_documents),
                "{:,}".format(total_updated),
            )

    LOGGER.info(
        "Finished update with %s document(s) updated", "{:,}".format(total_updated)
    )


def main():
    """Check and optionally update the GeoIP data for given IP(s) or owner(s)."""
    args = docopt(__doc__, version="v0.0.1")

    cyhy_db = database.db_from_config(args["--section"])
    geoip_db = GeoLocDB()

    # Set up logging
    logging_setup(args["--debug"])

    if args["check"]:
        do_check(cyhy_db, geoip_db, args["ADDRESS"])
    elif args["update"]:
        if args["OWNER"]:
            for owner in args["OWNER"]:
                do_update(cyhy_db, geoip_db, args["--live-only"], owner)
        else:
            do_update(cyhy_db, geoip_db, args["--live-only"])


if __name__ == "__main__":
    main()
