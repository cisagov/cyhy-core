#!/usr/bin/env python

"""Perform hostname housekeeping tasks.

Usage:
  cyhy-domainsync [options]
  cyhy-domainsync (-h | --help)
  cyhy-domainsync --version

Options:
  -f FILE --config-file=FILE      Configuration file to use.
  -h --help                       Show this screen.
  -o OWNER --default-owner=OWNER  Default owner to use for new HostDocs [default: CYHY].
  -r IP --resolver=IP             IP address of DNS resolver to use.
  -s SECTION --section=SECTION    Configuration section to use.
  --version                       Show version.
"""

# standard python libraries
import logging

# third-party libraries (install with pip)
from dns import resolver, exception
from docopt import docopt
from netaddr import IPAddress, AddrFormatError

# intra-project modules
from cyhy.db import database
from cyhy.core.common import STAGE


def get_requests(db):
    """Yield each of the non-retired owners in the database."""
    requests = db.RequestDoc.find(spec={"retired":False}, sort=[("_id", 1)])
    for r in requests:
        yield r

def get_ipv4_addresses(hostname):
    """Return a set of IPv4 addresses for the given hostname."""
    try:
        answers = resolver.query(hostname, 'A')
        ip_list = [IPAddress(answer.address) for answer in answers]
        return set(ip_list)
    except exception.DNSException as e:
        # Could not resolve domain name
        return set()
    except AddrFormatError:
        return set()
    
def main():
    args = docopt(__doc__, version="v0.0.1")
    try:
        db = database.db_from_config(args["--section"], args["--config-file"])

        if args["--resolver"]:
            # If a resolver was specified, configure the default resolver to use it
            resolver.default_resolver = resolver.Resolver(configure=False)
            resolver.default_resolver.nameservers = [args["--resolver"]]

        default_owner = args["--default-owner"]
        print("Using default owner: " + default_owner)

        # TODO lookup starting stage for default_owner
        starting_stage = STAGE.NETSCAN1

        for r in get_requests(db):
            print(r["_id"])
            for hostname in r.get("hostnames", []):
                print("\t" + hostname),
                # Find all the HostDocs that have this domain name as a value in their hostnames dictionary
                hostdocs = db.HostDoc.get_by_hostname(hostname)

                print("\t" + str(hostdocs.count()) + " HostDocs currently reference this hostname")

                ip_set = get_ipv4_addresses(hostname)
                print("\t" + str(len(ip_set)) + " IPv4 addresses found for this hostname")
                for ip in ip_set:
                    print("\t\t" + str(ip))
                    # Lookup the HostDoc for this IP address
                    host_doc = db.HostDoc.get_by_ip(ip)

                    # If it doesn't exist, create it, with our default owner and add the request ID and domain to the list of owners
                    if not host_doc:
                        host_doc = db.HostDoc()
                        # TODO lookup location for new HostDoc
                        location = (0,0)
                        host_doc.init(ip, default_owner, location, starting_stage)
                        host_doc["hostnames"] = [{"hostname": hostname, "owner": r["_id"]}]
                        host_doc.save()
                        print("Created new " + default_owner + " HostDoc for " + str(ip))
                        continue

                    # The HostDoc did exist, so add the request ID and domain to the list of owners
                    
                    # HostDoc.hostnames is a list of dictionaries with the following keys: hostname, owner
                    # An example looks like this:
                    # "hostnames": [
                    #     { "hostname": "foo.gov", "owner": "FOO" },
                    #     { "hostname": "dev.foo.gov", "owner": "FOO" }
                    # ]

                    # If the hostnames list doesn't exist, create it
                    if not host_doc.get("hostnames"):
                        host_doc["hostnames"] = []

                    # If the hostname isn't already in the list, add it
                    if not any(h["hostname"] == hostname for h in host_doc["hostnames"]):
                        host_doc["hostnames"].append({"hostname": hostname, "owner": r["_id"]})
                    
                    # Save the HostDoc
                    host_doc.save()

                # Remove outdated hostnames from Hostdocs
                for host in hostdocs:
                    # If the hostdoc ip is not in the ip_set, remove the domain from the list of owners
                    if host.ip not in ip_set:
                        print("\t\tRemoving " + hostname + " from " + str(host.ip))
                        host["hostnames"] = [i for i in host["hostnames"] if i["hostname"] != hostname]
                        host.save()
 
                        # Close all open tickets with this ip and hostname
                        # TODO: db.TicketDoc.close_tickets(host.ip, hostname)
        
        # Find all the Default Owner HostDocs that don't have any hostnames, and 
        # print out how many were deleted
        print("Deleting " + default_owner + " HostDocs that have no hostnames...")
        result = db.HostDoc.collection.delete_many({"owner": default_owner, "hostnames": {"$size": 0}})

        # Print out how many documents were deleted
        print("Deleted " + str(result.deleted_count) + " HostDocs")
            
        # Synchronize the default owner's TallyDoc
        tally_doc = db.TallyDoc.get_by_owner(default_owner)
        if not tally_doc:
            tally_doc = db.TallyDoc()
            tally_doc["_id"]= default_owner
            tally_doc.save()
        tally_doc.sync(db)
        print("Synchronized " + default_owner + " TallyDoc")


    except:
        logging.exception("Unexpected exception")


if __name__ == "__main__":
    main()
